\documentclass[a4paper]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{csquotes}
\usepackage{listings}
\usepackage{multicol}
\lstset{language=c,frame=single,captionpos=b}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage[backend=biber, sorting=none,maxbibnames=40]{biblatex}
\renewbibmacro{in:}{}
\addbibresource{ref.bib}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[margin=2.5cm]{geometry}
\usepackage{subcaption}
\usepackage[affil-it]{authblk}
\usepackage{color}
\usepackage{amssymb,amsmath}
\usepackage{subfloat}
\usepackage{float}

\begin{document}
\title{JAVA Assignment: Rubik's Cube}
\author{Stefano Sandon√†}
\affil{Vrije Universiteit Amsterdam, Holland}
\date{}
		
\maketitle

\section{The Rubik's Cube}
\label{sec:rubiks_cube}

A Rubik's Cube is a puzzle designed by Mr Rubik. In a Rubik's Cube, each of the faces is covered by colored stickers. In the initial setting, all the stickers of a face are of the same color and different colors are used for different faces. After performing some random twists, the aim of the game is to twist the cube until every side returns to be of a single color. 

\section{The Sequential Algorithm}
\label{sec:seq_algo}
The idea behind the sequential algorithm is simple. From a starting cube, we can twist it in each axis, row and direction (Figure \ref{fig:tw}). For each cube of size \textit{S}, doing a twist, there are \textit{6*(S-1)} new possible cubes. In Figure \ref{fig:fig:iterations}, the evolution of the search is represented as a tree. It's easy to understand from the figure that there is a rapid growth of the tree, in fact at the tree level \textit{i} there are \textit{(6*(S-1))\textsuperscript{i}} nodes (cubes).
The used state space search strategy, is the \textbf{deepening depth-first search (IDDFS)}. A depth-limited search is run repeatedly, increasing the depth limit with each iteration until it reaches d, the depth of the shallowest goal state. When the bound is increased, the solution search starts again from the begin (the root), and continues until the bound level is reached. On each iteration, the algorithm visits the nodes in the search tree in the same order as depth-first search, but the cumulative order in which nodes are first visited is effectively breadth-first. The first 2 iterations of the algorithm, with the order of the cube's evaluation is shown in Figure \ref{fig:iterations}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.5\linewidth]{xyz}
  \caption{Possible directions and axis for twists in a 3d cube}
  \label{fig:tw}
\end{figure}
\FloatBarrier

\begin{figure}
\begin{subfigure}{0.40\textwidth}
\includegraphics[width=\linewidth]{rubik_tree_eval1}
\caption{First itaration (bound=1)} \label{fig:ita}
\end{subfigure}
\hspace*{\fill} % separation between the subfigures
\begin{subfigure}{0.60\textwidth}
\includegraphics[width=\linewidth]{rubik_tree_eval2}
\caption{Second itaration (bound=2)} \label{fig:itb}
\end{subfigure}
\caption{The IDDFS Algorithm} \label{fig:iterations}
\end{figure}
\FloatBarrier

\section{The Parallel Algorithm}
\label{sec:par_algo}
An efficient parallelization of this algorithm is not trivial because of the work distribution. At each tree level, there are \textit{(6*(cubeSize-1))\textsuperscript{i}} cubes, and this number is most likely not a multiple of the available nodes involved in the computation. Another aspect, consist on the organization of the entire work, due to the fact that after each tree bound level is reached, we have to decide if the work is finished or not.  The next paragraph was introduced to clarify terms and concepts that will be used in the rest part of the report.

\subsection{The Ibis Portability Layer (IPL)}
\label{sec:ibis}
For this project was used an efficient platform for distributed computing: Ibis. This is a Java-centric communication system designed for grid computing, developed at VU University, Amsterdam. A fundamental concept in Ibis is the Pool, that is a set of one or more Ibis instances, often distributed in different machines. Each Ibis instance, that joined a specific pool, has an unique id and can cooperate with the others, running a single distributed application. With the election mechanism of Ibis, one machine can be elected as "master" and so be the "coordinator" or the central point of the entire work. Thanks to the registry mechanism, each Ibis instance can also know all the other Ibises that joined the same Pool and communicate with them. The core of the Ibis system is the  Ibis Portability layer (IPL), that is a communication library specifically designed for usage in a grid environment. It is based on setting up connections. The programmer can create send/receive ports (with a name) and connect them in a flexible way: one-to-one, one-to-many, many-to-one. In addition, the programmer can define properties of connections and ports like reliability, FIFO ordering, ... . Proceeding in this way, after a port configuration, the only thing to do is to send a message through this port, the library will take care of the rest. 

\subsection{Cubes distribution}
\label{sec:cubes_distr}
The work distribution, or better the cubes distribution, is the central part of the parallel implementation. The more balanced is the work among the involved nodes and the more will be the achieved performance. The major problem with a static partitioning, is that at each tree level, a number multiple of 6 of cubes are generated, and this is often not perfect divisible by the number of involved machines. A naive approach could generate the first levels of the tree and when there are enough nodes (more than the number of Ibis instances involved), distribute them as fairly as possible. However, this could lead to a big load imbalance and, as conseguece, not good performance. For example, with a 3d cube and 5 machines, the tree will be unroll until level 1. The 12 resulting cubes would be divided into 3 3 2 2 2 and assigned to the 5 machines. This means that the first 2 machines would work 1.5 times the others. To outline the gravity of this, if \textit{m} (the goal tree level) is big enough, it could be possible that the last 3 macchines worked for an entire day (24 hours), and the first two machines worked for one day and a half (36 hours). The total computational time would be 36 hours and for 12 hours the last 3 machines would be idle. 
The basic idea of amplify the tree until there are enough nodes is correct, but the load imbalance factor must be considered. 

\subsubsection{Cube Weight}
\label{sec:cw}

After an accurate evaluation, a "weight" can be assigned to each cube, based on the amount of the next cubes that will be generated from it. This weight is represented in Equation\ref{eq:eqWe}, where \textit{m} is the tree level in which there will be the solution (unknown at the begin), \textit{n} is \textit{6*(cubeSize-1)} so the number of possible children per cube and \textit{z} is the actual tree level of the cube.

\begin{equation} 
\label{eq:eqWe}
Weight = \sum_{i=0}^{m-z}{n^i}
\end{equation}
\FloatBarrier

As clarification, a practical example is reported in Figure \ref{fig:treeBin}. In this example, that is not related to the Rubik's Cube, but just to explain the general idea, \textit{n=2}, \textit{z1=1}, \textit{z2=2}, \textit{m=4}. Applying the previous formula, the weight of the first cube (at z1 level) is \textit{2\textsuperscript{0}+2\textsuperscript{1}+2\textsuperscript{2}+2\textsuperscript{3}=15}, because from it 14 cubes will be generated, so 15 (counting also the root node) will be evaluated in total. The weight of the second cube (at z2 level), is \textit{2\textsuperscript{0}+2\textsuperscript{1}+2\textsuperscript{2}=7}. 

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.8\linewidth]{tree_bin}
  \caption{Rubik's Cube Solution Tree}
  \label{fig:treeBin}
\end{figure}
\FloatBarrier

\subsubsection{Load balancing}
\label{sec:lb}

Give a weight to a cube is useful, because it should be correct to assign to each Ibis instance more or less the same work to do. Given the fact that the number of cubes on a tree level often is not a multiple of the nodes involved on the computation, there will be load imbalance at a certain point. Also distributing the nodes at a specific tree level as fairly as possible, there will be one or more Ibis instances with one more cube than the others, for a gap of maximum one cube. The only thing to do, is to select the correct tree level in which have this load imbalance, in order to limit the deriving damages. Looking at the previous formula, at the begin of the computation \textit{n} is known because the size of the cube is known, \textit{m} is unknown, is part of the solution, and \textit{z} is the value that we want to find. As just said, given enough cubes (more than the number of Ibis instances), the maximum difference of assigned cubes is one cube. In fact, this is possible using a simple \textit{for} construct (Listing \ref{fair}).

\begin{lstlisting}[label=fair, caption=fair distribution of cubes]
int sum = 0;
int rem = numCubes % numProcs; 
for (i = 0; i < numprocs; i++) {
    cubes_per_proc[i] = numCubes / numProcs;
    if (rem > 0) {
        cubes_per_proc[i]++;
        rem--;
    }
    displs[i] = sum;
    sum += cubes_per_proc[i];
}
\end{lstlisting}
\FloatBarrier

At a certain tree level \textit{z}, there are \textit{n\textsuperscript{z}} cubes and the relative weight per cube is the one shown in Equation\ref{eq:eqWe}. With the previous code, calling \textit{k} the number of machines involved in the computation, the lowest amount of work assigned per slave, is shown in Equation \ref{eq:eqLow}, while the highest is shown in Equation \ref{eq:eqHig}. 

\begin{equation} 
\label{eq:eqLow}
LW=\sum_{i=0}^{m-z}{n^i}*\lfloor\frac{n^z}{k}\rfloor
\end{equation}
\FloatBarrier

\begin{equation} 
\label{eq:eqHig}
HW=\sum_{i=0}^{m-z}{n^i}*\lfloor\frac{n^z}{k}\rfloor +  \sum_{i=0}^{m-z}{n^i}
\end{equation}
\FloatBarrier

To reduce the load imbalance as much as possible, the two amounts of work should differ as little as possible. That means that \textit{HW*100/LW} has to be as near to 100 as possible, for example lower than 101, that means that a maximum of 1\% of load imbalance is permitted. Solving the inequality shown in Equation \ref{eq:eqIne}, the solution is the one shown in Equation \ref{eq:eqSol}. 

\begin{equation} 
\label{eq:eqIne}
\frac{(\sum_{i=0}^{m-z}{n^i}*\lfloor\frac{n^z}{k}\rfloor +  \sum_{i=0}^{m-z}{n^i})*100}{(\sum_{i=0}^{m-z}{n^i}*\lfloor\frac{n^z}{k}\rfloor)} < 101
\end{equation}
\FloatBarrier

\begin{equation} 
\label{eq:eqSol}
\lfloor\frac{n^z}{k}\rfloor > 100
\end{equation}
\FloatBarrier

At the begin \textit{n} (the size of the cube) is known and also \textit{k} (the number of Ibises that joined the pool), so the value to find is \textit{z}. In addition to reduce the load imbalance, it's useful to reduce the tree unroll at the minimum. For this reason, the final value to find is the one shown in Equation \ref{eq:eqSol2}.

\begin{equation} 
\label{eq:eqSol2}
\min_{z>0} \lfloor\frac{n^z}{k}\rfloor > 100
\end{equation}
\FloatBarrier

\subsubsection{Work split}
\label{sec:ws}

Once found the correct value of \textit{z}, this is the tree level in which to have an imbalance of 1 cube, isn't such a big risk for the performance. 
To reduce the unrolls (the initial work), the tree is extended A) until the level \textit{z-1} if at that level there are enough nodes (more than the Ibis instances) (FIGURE), otherwise B) until the level \textit{z} (FIGURE). If we are in case A, the \textit{n\textsuperscript{(z-1)}} nodes are divided in equal parts to the machines. If some nodes have left out (\textit{k} is not a divisor of the number of nodes of this level), these are expanded to the next tree level (FIGURE A), otherwise the splitting phase is terminated (FIGURE C). If we have expanded some nodes, we try to split them among the Ibis instances. Until they are less than the number of ibis instances we generate another level of the tree from them. When they are enough, we split them as fairly as possible (Listing \ref{fair}) (FIGURE B and A). If we are in case B we just split the \textit{n\textsuperscript{(z)}} nodes as fairly as possible (FIGURE).




\subsection{Ibis setting}
\label{sec:ibis_setting}
Each node involved in the computation is an Ibis instance with an unique identifier.
When a tree level bound is reached, each Ibis instance has to communicate its results (if a solution is founded on the assigned subtree and, in the case, how many) and has to decide if continue with the next bound or not. The most obvious solution, is to adopt a "master slave" approach and use the "master" Ibis instance to collect the partial results and decide if the work is finished or continue with the next bound. To do this 4 ports are needed. On the master side 2 ports are needed, one to receive the results from the slaves and one to send if the  the work is finisched. Specularly, on the slaves side, 2 ports are needed, one to communicate the solutions found and one to receive if the if the next bound has to be evaluated or the work is finished. A graphic representation is presented in Figure \ref{fig:ports}.

\begin{figure}
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.5\linewidth]{results}
\caption{Results communication - Many to 1} \label{fig:ca}
\end{subfigure}
\hspace*{\fill} % separation between the subfigures
\begin{subfigure}{0.5\textwidth}
\centering
\includegraphics[width=0.5\linewidth]{continue}
\caption{Work status communication - 1 to Many} \label{fig:cb}
\end{subfigure}
\caption{Send (circle) and Receive (square) Ports organization} \label{fig:ports}
\end{figure}
\FloatBarrier


\printbibliography 

\end{document}